@use "../settings/mixins" as *;
@use "../settings/variables" as *;
@use "../components/extend" as *;
@use 'sass:math';
@use 'sass:color';


$itemCnt: 11;
$picWidth: 100px;
$interval: 30px;
$r: math.div(($picWidth + $interval) * $itemCnt, 2 * math.$pi);
.picList {
  position: relative;
  width: 100%;
  height: 70vh;
  min-height: 420px;
  transform: rotateX(-5deg);
  // transform: rotate3d(1,0,0,-5deg);
  transform-style: preserve-3d;
  perspective: (2 * $r);
}

.pic {
  position: absolute;
  top: 50%;
  left: calc(50% - $picWidth / 2);
  width: $picWidth;
  // height: $picWidth;
  padding: 1em;
  transition: .5s;
  opacity: 0.9;
  background: #eee;
  &_name {
    position: absolute;
    top: 105%;
    left: 0;
    width: 100%;
    font-size: 1rem;
    transition: .5s;
    text-align: center;
    opacity: 0;
  }
}

// https://sass-lang.com/documentation/modules/color

// @for $childNo from 1 through $itemCnt {
//   $rad: math.div(math.$pi * 2 * ($childNo - 1), $itemCnt);
//   @keyframes circle#{$childNo} {
//     100% {
//       transform: translate3d($r * math.sin($rad),0,$r * math.cos($rad)) rotateY($rad + rad);
//     }
//   }
// }

// この方法では最前面に移動する際、回転することは免れない
@for $childNo from 1 through $itemCnt {
  $deg: math.div(360 * $childNo, $itemCnt);
  .pic:nth-child(#{$childNo}) {
    background: adjust-hue(#f8d6ba, $deg);
  }

  @for $frontNo from 1 through $itemCnt {
    $rad: math.div(math.$pi * 2 * ($childNo - $frontNo), $itemCnt);
    @if ($rad < 0) {
      $rad: $rad + 2 * math.$pi;
    }

    .picList[data-front='#{$frontNo}'] {
      .pic:nth-child(#{$childNo}) {
        z-index: math.ceil($itemCnt * math.cos($rad));
        transform: translate3d($r * math.sin($rad),0,$r * math.cos($rad)) rotateY($rad + rad);
        // @if ($frontNo <= $childNo) {
        //   animation: circle#{$childNo - $frontNo + 1} .5s forwards;
        // }
        // @else {
        //   animation: circle#{$itemCnt - $frontNo + $childNo + 1} .5s forwards;
        // }

        @if ($childNo == $frontNo) {
          // transform: translate3d($r * math.sin($rad), -10px,$r * math.cos($rad)) rotateY(4 * math.$pi + rad) scale(1.3);
          // transform: translate3d($r * math.sin($rad),0,$r * math.cos($rad)) rotateY(0deg);
          // animation: frontAnime .5s;
          .pic_name {
            opacity: 1;
          }
        }
      }
    }
  }
}

// $pos2ndRad: math.div(math.$pi * 2, $itemCnt);
// @if ($pos2ndRad < 0) {
//   $preRad: $preRad + 2 * math.$pi;
// }

// $posLastRad: math.div(math.$pi * 2 * ($itemCnt - 1), $itemCnt);
// @if ($pos2ndRad < 0) {
//   $posLastRad: $preRad + 2 * math.$pi;
// }


// 最前面に来た時
// @keyframes frontAnime {
//   0% {
//     transform: translate3d(-$r * math.sin($pos2ndRad),0,$r * math.cos($pos2ndRad)) rotateY(-1 * $pos2ndRad + rad); // 2の場所
//     // transform: translate3d(-$r * math.sin($posLastRad),0,$r * math.cos($posLastRad)) rotateY(2 * math.$pi - $posLastRad + rad); // 最後の場所
//   }
//   99% {
//     // transform: translate3d(0,0,$r) rotateY(0deg);
//   }
//   100% {
//     transform: translate3d(0,0,$r) rotateY(0rad);
//   }
// }

// MEMO:
// keyframesを使って色々やってみたけど、片方向にだけの時しかうまくいかないし、アニメーションが終わる前にボタン押下したら表示おかしくなるし、、、
// というわけで、やっぱり無理っぽい。。。ざんねん


// ボタン
.btn {
  display: inline-block;
  margin-top: 4em;
  padding: 0.5em 1em;
  color: #333;
  border: none;
  background: #eee;

  + .btn {
    margin-left: 2em;
  }
}

